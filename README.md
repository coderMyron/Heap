# Heap
堆：最大堆、最小堆

堆，其实是一个完整的二叉树（除了叶节点外，其他节点都有左右子节点）。堆有以下两种形式：
## 最大堆：
```
根部元素的值最大，越往下，值越小。例如  
         10 
       /   \     
      7     9  
     / \   / \  
    6   4 5   3   
```
## 最小堆：
```
根部元素的值最小，越往下，值越大。例如：
         1 
       /   \     
      2     3  
     / \   / \  
    6   8 9   7   
```

虽然堆本质上是属于二叉树，但是我们不是用节点来实现，而是使用**数组**。因为堆中的元素有一定的优先级顺序，可以用数组来存储元素；并且在元素的添加移除等过程中需要频繁访问特定的位置的元素，数组正适合我们的需求。  
考虑到堆有两种形式，所以定义了一个**order**闭包。

### 如果给定一个元素的索引 i，那么：
* 这个元素的左子节点索引为 2 * i + 1，这个元素的右子节点索引为 2 * i + 2。  
* 这个元素的父节点索引为 (i - 1) / 2  

### 插入
插入到最后位置，再向上比较调整

### 删除
* 删除根部
根部跟最后一个位置交换位置，再删除最后位置数据，然后根部再向下比较调整数据。
* 删除任意位置
同样与最后一个位置交换位置，再删除最后位置数据，然后任意那个位置再向下比较调整数据和向上比较调整。

### 查找
从左右分支用递归查找，如果找到则返回对数的索引，找不到返回nil。

### 示例
```
var heap = Heap<Int>(order: >)
for i in 1...7 {
    heap.insert(i)
}

print(heap)

print("删除根部")
while !heap.isEmpty {
    if let num = heap.removePeek() {
        print(num)
    }
}
        
//        print("删除元素2")
//        let index = heap.index(of: 2) ?? 0
//        if let remove = heap.remove(at: index) {
//            print(remove)
//        }else {
//            print("没有找到要删除的数据")
//        }
```

### 打印
```
[7, 4, 6, 1, 3, 2, 5]
删除根部
7
6
5
4
3
2
1
```
